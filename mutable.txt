-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Piecewise-mutable references for product types
--   
--   Please see the README on GitHub at
--   <a>https://github.com/mstksg/mutable#readme</a>
@package mutable
@version 0.1.0.0


-- | Abstract over different types for mutable references of values.
module Data.Mutable.Class
class Monad m => Mutable m a where {
    type family Ref m a = (v :: Type) | v -> a;
    type Ref m a = MutVar (PrimState m) a;
}
thawRef :: Mutable m a => a -> m (Ref m a)
freezeRef :: Mutable m a => Ref m a -> m a
copyRef :: Mutable m a => Ref m a -> a -> m ()

-- | Apply a pure function on an immutable value onto a value stored in a
--   mutable reference.
modifyRef :: Mutable m a => Ref m a -> (a -> a) -> m ()

-- | <a>modifyRef</a>, but forces the result before storing it back in the
--   reference.
modifyRef' :: Mutable m a => Ref m a -> (a -> a) -> m ()

-- | Apply a pure function on an immutable value onto a value stored in a
--   mutable reference, returning a result value from that function.
updateRef :: Mutable m a => Ref m a -> (a -> (a, b)) -> m b

-- | <a>updateRef</a>, but forces the updated value before storing it back
--   in the reference.
updateRef' :: Mutable m a => Ref m a -> (a -> (a, b)) -> m b
thawRef :: (Mutable m a, DefaultMutable m a (Ref m a)) => a -> m (Ref m a)
freezeRef :: (Mutable m a, DefaultMutable m a (Ref m a)) => Ref m a -> m a
copyRef :: (Mutable m a, DefaultMutable m a (Ref m a)) => Ref m a -> a -> m ()

-- | Newtype wrapper that can provide any type with a <a>Mutable</a>
--   instance. Can be useful for avoiding orphan instances.
newtype MutRef a
MutRef :: a -> MutRef a
[runMutRef] :: MutRef a -> a
newtype RefFor m a
RefFor :: Ref m a -> RefFor m a
[getRefFor] :: RefFor m a -> Ref m a
class DefaultMutable m a r
defaultThawRef :: DefaultMutable m a r => a -> m r
defaultFreezeRef :: DefaultMutable m a r => r -> m a
defaultCopyRef :: DefaultMutable m a r => r -> a -> m ()
class Monad m => GMutable m f where {
    type family GRef_ m f = (u :: Type -> Type) | u -> f;
}
newtype GRef m a
GRef :: GRef_ m (Rep a) () -> GRef m a
[unGRef] :: GRef m a -> GRef_ m (Rep a) ()
gThawRef :: (Generic a, GMutable m (Rep a)) => a -> m (GRef m a)
gFreezeRef :: (Generic a, GMutable m (Rep a)) => GRef m a -> m a
gCopyRef :: (Generic a, GMutable m (Rep a)) => GRef m a -> a -> m ()
thawHKD :: forall z m. (Generic (z Identity), Generic (z (RefFor m)), GMutable m (Rep (z Identity)), GRef_ m (Rep (z Identity)) ~ Rep (z (RefFor m))) => z Identity -> m (z (RefFor m))
freezeHKD :: forall z m. (Generic (z Identity), Generic (z (RefFor m)), GMutable m (Rep (z Identity)), GRef_ m (Rep (z Identity)) ~ Rep (z (RefFor m))) => z (RefFor m) -> m (z Identity)
copyHKD :: forall z m. (Generic (z Identity), Generic (z (RefFor m)), GMutable m (Rep (z Identity)), GRef_ m (Rep (z Identity)) ~ Rep (z (RefFor m))) => z (RefFor m) -> z Identity -> m ()
newtype RecRef m f a
RecRef :: Ref m (f a) -> RecRef m f a
[recRef] :: RecRef m f a -> Ref m (f a)

-- | If you can provice a natural transformation from <tt>m</tt> to
--   <tt>n</tt>, you should be able to use a value as if it had
--   <tt><a>Mutable</a> n a</tt> if you have <tt><a>Mutable</a> m a</tt>.
reMutable :: forall m n a r. (Mutable m a, Monad n) => (forall x. m x -> n x) -> (Mutable n a => r) -> r

-- | If you can provice a natural transformation from <tt>m</tt> to
--   <tt>n</tt>, then <tt><a>Mutable</a> m a</tt> should also imply
--   <tt><a>Mutable</a> n a</tt>.
reMutableConstraint :: forall m n a. (Mutable m a, Monad n) => (forall x. m x -> n x) -> Mutable m a :- Mutable n a
newtype ReMutable (s :: Type) m a
ReMutable :: a -> ReMutable (s :: Type) m a
newtype ReMutableTrans m n
RMT :: (forall x. m x -> n x) -> ReMutableTrans m n
[runRMT] :: ReMutableTrans m n -> forall x. m x -> n x
instance (GHC.Base.Monad n, Data.Mutable.Class.Mutable m a, Data.Reflection.Reifies s (Data.Mutable.Class.ReMutableTrans m n)) => Data.Mutable.Class.Mutable n (Data.Mutable.Class.ReMutable s m a)
instance (GHC.Generics.Generic a, Data.Mutable.Class.GMutable m (GHC.Generics.Rep a)) => Data.Mutable.Class.DefaultMutable m a (Data.Mutable.Class.GRef m a)
instance (GHC.Generics.Generic (z Data.Functor.Identity.Identity), GHC.Generics.Generic (z (Data.Mutable.Class.RefFor m)), Data.Mutable.Class.GMutable m (GHC.Generics.Rep (z Data.Functor.Identity.Identity)), Data.Mutable.Class.GRef_ m (GHC.Generics.Rep (z Data.Functor.Identity.Identity)) GHC.Types.~ GHC.Generics.Rep (z (Data.Mutable.Class.RefFor m))) => Data.Mutable.Class.DefaultMutable m (z Data.Functor.Identity.Identity) (z (Data.Mutable.Class.RefFor m))
instance Data.Mutable.Class.Mutable m c => Data.Mutable.Class.GMutable m (GHC.Generics.K1 i c)
instance (Data.Mutable.Class.GMutable m f, Data.Mutable.Class.GMutable m g) => Data.Mutable.Class.GMutable m (f GHC.Generics.:*: g)
instance Data.Mutable.Class.GMutable m f => Data.Mutable.Class.GMutable m (GHC.Generics.M1 i c f)
instance (Data.Mutable.Class.GMutable m f, Data.Mutable.Class.GMutable m g, Control.Monad.Primitive.PrimMonad m) => Data.Mutable.Class.GMutable m (f GHC.Generics.:+: g)
instance forall u (m :: * -> *) (f :: u -> *). GHC.Base.Monad m => Data.Mutable.Class.Mutable m (Data.Vinyl.Core.Rec f '[])
instance forall a1 (m :: * -> *) (f :: a1 -> *) (a2 :: a1) (as :: [a1]). (GHC.Base.Monad m, Data.Mutable.Class.Mutable m (f a2), Data.Mutable.Class.Mutable m (Data.Vinyl.Core.Rec f as), Data.Mutable.Class.Ref m (Data.Vinyl.Core.Rec f as) GHC.Types.~ Data.Vinyl.Core.Rec (Data.Mutable.Class.RecRef m f) as) => Data.Mutable.Class.Mutable m (Data.Vinyl.Core.Rec f (a2 : as))
instance Control.Monad.Primitive.PrimMonad m => Data.Mutable.Class.Mutable m (Data.Mutable.Class.MutRef a)
instance Data.Vinyl.XRec.IsoHKD Data.Mutable.Class.MutRef a
instance Data.Mutable.Class.Mutable m a => Data.Mutable.Class.Mutable m (Data.Functor.Identity.Identity a)
instance Control.Monad.Primitive.PrimMonad m => Data.Mutable.Class.Mutable m GHC.Types.Int
instance Control.Monad.Primitive.PrimMonad m => Data.Mutable.Class.Mutable m GHC.Integer.Type.Integer
instance Control.Monad.Primitive.PrimMonad m => Data.Mutable.Class.Mutable m (GHC.Real.Ratio a)
instance Control.Monad.Primitive.PrimMonad m => Data.Mutable.Class.Mutable m GHC.Types.Float
instance Control.Monad.Primitive.PrimMonad m => Data.Mutable.Class.Mutable m GHC.Types.Double
instance Control.Monad.Primitive.PrimMonad m => Data.Mutable.Class.Mutable m (Data.Complex.Complex a)
instance Control.Monad.Primitive.PrimMonad m => Data.Mutable.Class.Mutable m GHC.Types.Bool
instance Control.Monad.Primitive.PrimMonad m => Data.Mutable.Class.Mutable m (Data.Vector.Vector a)
instance (Control.Monad.Primitive.PrimMonad m, Foreign.Storable.Storable a) => Data.Mutable.Class.Mutable m (Data.Vector.Storable.Vector a)
instance (Control.Monad.Primitive.PrimMonad m, Data.Vector.Unboxed.Base.Unbox a) => Data.Mutable.Class.Mutable m (Data.Vector.Unboxed.Base.Vector a)
instance (Control.Monad.Primitive.PrimMonad m, Data.Primitive.Types.Prim a) => Data.Mutable.Class.Mutable m (Data.Vector.Primitive.Vector a)
instance (Control.Monad.Primitive.PrimMonad m, Data.Vector.Generic.Base.Vector v a) => Data.Mutable.Class.Mutable m (Data.Vector.Generic.Sized.Internal.Vector v n a)
instance GHC.Base.Monad m => Data.Mutable.Class.Mutable m ()
instance (GHC.Base.Monad m, Data.Mutable.Class.Mutable m a, Data.Mutable.Class.Mutable m b) => Data.Mutable.Class.Mutable m (a, b)
instance (GHC.Base.Monad m, Data.Mutable.Class.Mutable m a, Data.Mutable.Class.Mutable m b, Data.Mutable.Class.Mutable m c) => Data.Mutable.Class.Mutable m (a, b, c)
instance (GHC.Base.Monad m, Data.Mutable.Class.Mutable m a, Data.Mutable.Class.Mutable m b, Data.Mutable.Class.Mutable m c, Data.Mutable.Class.Mutable m d) => Data.Mutable.Class.Mutable m (a, b, c, d)
instance (Control.Monad.Primitive.PrimMonad m, s GHC.Types.~ Control.Monad.Primitive.PrimState m) => Data.Mutable.Class.DefaultMutable m a (Data.Primitive.MutVar.MutVar s a)

module Data.Mutable.MutPart
newtype MutPart m s a
MutPart :: (Ref m s -> Ref m a) -> MutPart m s a
[getMutPart] :: MutPart m s a -> Ref m s -> Ref m a
freezePart :: Mutable m a => MutPart m s a -> Ref m s -> m a
copyPart :: Mutable m a => MutPart m s a -> Ref m s -> a -> m ()
modifyPart :: Mutable m a => MutPart m s a -> Ref m s -> (a -> a) -> m ()
modifyPart' :: Mutable m a => MutPart m s a -> Ref m s -> (a -> a) -> m ()
updatePart :: Mutable m a => MutPart m s a -> Ref m s -> (a -> (a, b)) -> m b
updatePart' :: Mutable m a => MutPart m s a -> Ref m s -> (a -> (a, b)) -> m b
hkdMutPart :: forall m z. (Generic (z (RefFor m)), Generic (z (MutPart m (z Identity))), HKDMutPart m z (Rep (z (RefFor m))) (Rep (z (MutPart m (z Identity))))) => z (MutPart m (z Identity))
class (Mutable m s, Mutable m a) => FieldMut (fld :: Symbol) m s a | fld s -> a
fieldMut :: FieldMut fld m s a => Fld fld -> MutPart m s a
data Fld (fld :: Symbol)
Fld :: Fld (fld :: Symbol)
class (Mutable m s, Mutable m a) => PosMut (i :: Nat) m s a | i s -> a
posMut :: PosMut i m s a => MutPart m s a
instance GHC.Show.Show (Data.Mutable.MutPart.Fld fld)
instance (Data.Mutable.Class.Mutable m s, Data.Mutable.Class.Mutable m a, Data.Mutable.Class.Ref m s GHC.Types.~ Data.Mutable.Class.GRef m s, gref GHC.Types.~ Data.Mutable.MutPart.Fst (Data.Mutable.MutPart.Traverse (Data.Mutable.Class.GRef_ m (Data.Generics.Product.Internal.Positions.CRep s)) 1), GHC.Types.Coercible (Data.Mutable.Class.GRef_ m (GHC.Generics.Rep s) ()) (gref ()), Data.Generics.Product.Internal.GLens.GLens' (Data.Mutable.MutPart.HasTotalPositionPSym i) gref (Data.Mutable.Class.Ref m a), Data.Generics.Product.Positions.HasPosition' i s a) => Data.Mutable.MutPart.PosMut i m s a
instance (Data.Mutable.Class.Mutable m s, Data.Mutable.Class.Mutable m a, Data.Mutable.Class.Ref m s GHC.Types.~ Data.Mutable.Class.GRef m s, Data.Generics.Product.Internal.GLens.GLens' (Data.Mutable.MutPart.HasTotalFieldPSym fld) (Data.Mutable.Class.GRef_ m (GHC.Generics.Rep s)) (Data.Mutable.Class.Ref m a), Data.Generics.Product.Fields.HasField' fld s a) => Data.Mutable.MutPart.FieldMut fld m s a
instance (s GHC.Types.~ s') => GHC.OverloadedLabels.IsLabel s (Data.Mutable.MutPart.Fld s')
instance (Data.Mutable.Class.Mutable m (z Data.Functor.Identity.Identity), Data.Mutable.Class.Ref m (z Data.Functor.Identity.Identity) GHC.Types.~ z (Data.Mutable.Class.RefFor m)) => Data.Mutable.MutPart.HKDMutPart m z (GHC.Generics.K1 i (Data.Mutable.Class.RefFor m c)) (GHC.Generics.K1 i (Data.Mutable.MutPart.MutPart m (z Data.Functor.Identity.Identity) c))
instance forall k (m :: * -> *) (z :: (* -> *) -> *) (i :: k -> *) (o :: k -> *) a (b :: GHC.Generics.Meta). Data.Mutable.MutPart.HKDMutPart m z i o => Data.Mutable.MutPart.HKDMutPart m z (GHC.Generics.M1 a b i) (GHC.Generics.M1 a b o)
instance forall k (m :: * -> *) (z :: (* -> *) -> *) (i :: k -> *) (o :: k -> *) (i' :: k -> *) (o' :: k -> *). (Data.Mutable.MutPart.HKDMutPart m z i o, Data.Mutable.MutPart.HKDMutPart m z i' o') => Data.Mutable.MutPart.HKDMutPart m z (i GHC.Generics.:*: i') (o GHC.Generics.:*: o')
